class FileLockException(Exception):
    pass
 
class FileLock(object):
    """ A file locking mechanism that has context-manager support so 
        you can use it in a with statement.
    """
 
    def __init__(self, file_name, timeout=10, delay=.05):
        """ Prepare the file locker. Specify the file to lock and optionally
            the maximum timeout and the delay between each attempt to lock.
        """
	import os
        self.lock_level = 0
        self.lockfile = "%s.lock" % file_name
        if not os.path.isabs(file_name):
            self.lockfile = os.path.join(os.getcwd(), self.lockfile)
        self.timeout = timeout
        self.delay = delay
	self.fd = None
 
 
    def acquire(self):
        """ Acquire the lock, if possible. If the lock is in use, it check again
            every `wait` seconds. It does this until it either gets the lock or
            exceeds `timeout` number of seconds, in which case it throws 
            an exception.
        """
	if self.lock_level > 0:
	    # Already holding lock, just record the acquisition
	    self.lock_level += 1
	    return
	if self.fd is None:
	    self._createFile()
	import time
	start_time = time.time()
        while True:
            try:
		self._lock()
                break;
            except IOError as e:
                if (time.time() - start_time) >= self.timeout:
                    raise FileLockException("timeout acquiring lock")
                time.sleep(self.delay)
        self.lock_level = 1
 
 
    def release(self):
        """ Get rid of the lock by deleting the lockfile. 
            When working in a `with` statement, this gets automatically 
            called at the end.
        """
	if self.lock_level <= 0:
	    raise FileLockException("releasing unacquired lock")
	self.lock_level -= 1
	if self.lock_level == 0:
	    self._unlock()


    def holding_lock(self):
	""" Return whether we are holding the lock.
	"""
	return self.lock_level > 0


    def locked(self):
	""" Check whether someone is holding the lock.
	"""
	if self.lock_level > 0:
	    return True
	if self.fd is None:
	    self._createFile()
	try:
	    self._lock()
	except IOError as e:
	    return True
	else:
	    self._unlock()
	    return False


    def _createFile(self):
	import os
	try:
	    self.fd = os.open(self.lockfile, os.O_RDWR)
	except (OSError, IOError):
	    self.fd = os.open(self.lockfile, os.O_CREAT|os.O_RDWR)
	    os.write(self.fd, "%d\n" % os.getpid())
	    if os.name == "nt":
		# Set location for Windows file locking
		os.lseek(self.fd, 0, 0)


    def _lock(self):
	import os
	if os.name == "nt":
	    import msvcrt
	    msvcrt.locking(self.fd, msvcrt.LK_NBLCK, 1)
	elif os.name == "posix":
	    import fcntl
	    fcntl.flock(self.fd, fcntl.LOCK_EX | fcntl.LOCK_NB)
	else:
	    raise SystemError("unsupported platform \"%s\"" % os.name)


    def _unlock(self):
	import os
	if os.name == "nt":
	    import msvcrt
	    msvcrt.locking(self.fd, msvcrt.LK_UNLCK, 1)
	elif os.name == "posix":
	    import fcntl
	    fcntl.flock(self.fd, fcntl.LOCK_UN)
	else:
	    raise SystemError("unsupported platform \"%s\"" % os.name)
 
 
    def __enter__(self):
        """ Activated when used in the with statement. 
            Should automatically acquire a lock to be used in the with block.
        """
	self.acquire()
        return self
 
 
    def __exit__(self, type, value, traceback):
        """ Activated at the end of the with statement.
            It automatically releases the lock if it isn't locked.
        """
	self.release()
 
 
    def __del__(self):
        """ Make sure that the FileLock instance doesn't leave a lockfile
            lying around.
        """
	if self.lock_level > 0:
	    self._unlock()
	    # self.lock_level = 0
	if self.fd is not None:
	    import os
	    os.close(self.fd)
	    try:
		os.unlink(self.lockfile)
	    except OSError:
		pass
	    # self.fd = None
